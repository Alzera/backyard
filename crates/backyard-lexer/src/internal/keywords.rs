use crate::{ error::{ LexError, LexResult }, lexer::Lexer, token::{ Token, TokenType } };

pub struct KeywordToken;

impl KeywordToken {
  const KEYS: [&str; 70] = [
    "abstract",
    "array",
    "as",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "echo",
    "else",
    "elseif",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "exit",
    "eval",
    "die",
    "extends",
    "final",
    "finally",
    "fn",
    "for",
    "foreach",
    "from",
    "function",
    "global",
    "goto",
    "if",
    "implements",
    "include",
    "include_once",
    "instanceof",
    "insteadof",
    "interface",
    "list",
    "and",
    "or",
    "match",
    "namespace",
    "new",
    "print",
    "private",
    "protected",
    "public",
    "readonly",
    "require",
    "require_once",
    "return",
    "static",
    "parent",
    "self",
    "switch",
    "throw",
    "trait",
    "try",
    "use",
    "var",
    "while",
    "yield",
    "xor",
  ];

  pub fn is_keyword(input: &String) -> bool {
    Self::KEYS.contains(&input.as_str())
  }

  pub fn lex(input: &String, _: &mut Lexer) -> LexResult {
    match input.as_str() {
      "abstract" => Ok(vec![Token::new(TokenType::Abstract, input)]),
      "array" => Ok(vec![Token::new(TokenType::Array, input)]),
      "as" => Ok(vec![Token::new(TokenType::As, input)]),
      "break" => Ok(vec![Token::new(TokenType::Break, input)]),
      "callable" => Ok(vec![Token::new(TokenType::Callable, input)]),
      "case" => Ok(vec![Token::new(TokenType::Case, input)]),
      "catch" => Ok(vec![Token::new(TokenType::Catch, input)]),
      "class" => Ok(vec![Token::new(TokenType::Class, input)]),
      "clone" => Ok(vec![Token::new(TokenType::Clone, input)]),
      "const" => Ok(vec![Token::new(TokenType::Const, input)]),
      "continue" => Ok(vec![Token::new(TokenType::Continue, input)]),
      "declare" => Ok(vec![Token::new(TokenType::Declare, input)]),
      "default" => Ok(vec![Token::new(TokenType::Default, input)]),
      "do" => Ok(vec![Token::new(TokenType::Do, input)]),
      "echo" => Ok(vec![Token::new(TokenType::Echo, input)]),
      "else" => Ok(vec![Token::new(TokenType::Else, input)]),
      "elseif" => Ok(vec![Token::new(TokenType::ElseIf, input)]),
      "enddeclare" => Ok(vec![Token::new(TokenType::EndDeclare, input)]),
      "endfor" => Ok(vec![Token::new(TokenType::EndFor, input)]),
      "endforeach" => Ok(vec![Token::new(TokenType::EndForeach, input)]),
      "endif" => Ok(vec![Token::new(TokenType::EndIf, input)]),
      "endswitch" => Ok(vec![Token::new(TokenType::EndSwitch, input)]),
      "endwhile" => Ok(vec![Token::new(TokenType::EndWhile, input)]),
      "enum" => Ok(vec![Token::new(TokenType::Enum, input)]),
      "exit" => Ok(vec![Token::new(TokenType::Exit, input)]),
      "eval" => Ok(vec![Token::new(TokenType::Eval, input)]),
      "die" => Ok(vec![Token::new(TokenType::Die, input)]),
      "extends" => Ok(vec![Token::new(TokenType::Extends, input)]),
      "final" => Ok(vec![Token::new(TokenType::Final, input)]),
      "finally" => Ok(vec![Token::new(TokenType::Finally, input)]),
      "fn" => Ok(vec![Token::new(TokenType::Fn, input)]),
      "for" => Ok(vec![Token::new(TokenType::For, input)]),
      "foreach" => Ok(vec![Token::new(TokenType::Foreach, input)]),
      "from" => Ok(vec![Token::new(TokenType::From, input)]),
      "function" => Ok(vec![Token::new(TokenType::Function, input)]),
      "global" => Ok(vec![Token::new(TokenType::Global, input)]),
      "goto" => Ok(vec![Token::new(TokenType::Goto, input)]),
      "if" => Ok(vec![Token::new(TokenType::If, input)]),
      "implements" => Ok(vec![Token::new(TokenType::Implements, input)]),
      "include" => Ok(vec![Token::new(TokenType::Include, input)]),
      "include_once" => Ok(vec![Token::new(TokenType::IncludeOnce, input)]),
      "instanceof" => Ok(vec![Token::new(TokenType::InstanceOf, input)]),
      "insteadof" => Ok(vec![Token::new(TokenType::InsteadOf, input)]),
      "interface" => Ok(vec![Token::new(TokenType::Interface, input)]),
      "list" => Ok(vec![Token::new(TokenType::List, input)]),
      "and" => Ok(vec![Token::new(TokenType::And, input)]),
      "or" => Ok(vec![Token::new(TokenType::Or, input)]),
      "match" => Ok(vec![Token::new(TokenType::Match, input)]),
      "namespace" => Ok(vec![Token::new(TokenType::Namespace, input)]),
      "new" => Ok(vec![Token::new(TokenType::New, input)]),
      "print" => Ok(vec![Token::new(TokenType::Print, input)]),
      "private" => Ok(vec![Token::new(TokenType::Private, input)]),
      "protected" => Ok(vec![Token::new(TokenType::Protected, input)]),
      "public" => Ok(vec![Token::new(TokenType::Public, input)]),
      "readonly" => Ok(vec![Token::new(TokenType::Readonly, input)]),
      "require" => Ok(vec![Token::new(TokenType::Require, input)]),
      "require_once" => Ok(vec![Token::new(TokenType::RequireOnce, input)]),
      "return" => Ok(vec![Token::new(TokenType::Return, input)]),
      "static" => Ok(vec![Token::new(TokenType::Static, input)]),
      "parent" => Ok(vec![Token::new(TokenType::Parent, input)]),
      "self" => Ok(vec![Token::new(TokenType::SelfKeyword, input)]),
      "switch" => Ok(vec![Token::new(TokenType::Switch, input)]),
      "throw" => Ok(vec![Token::new(TokenType::Throw, input)]),
      "trait" => Ok(vec![Token::new(TokenType::Trait, input)]),
      "try" => Ok(vec![Token::new(TokenType::Try, input)]),
      "use" => Ok(vec![Token::new(TokenType::Use, input)]),
      "var" => Ok(vec![Token::new(TokenType::Var, input)]),
      "while" => Ok(vec![Token::new(TokenType::While, input)]),
      "yield" => Ok(vec![Token::new(TokenType::Yield, input)]),
      "xor" => Ok(vec![Token::new(TokenType::Xor, input)]),
      _ => Err(LexError::Unrecognized(input.to_owned())),
    }
  }
}
